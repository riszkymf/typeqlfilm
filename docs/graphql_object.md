## Defining a GraphQL Object

GraphQL Object is declared on [schemaModel.ts](../src/schemas/schemaModel.ts")
This file only allows ObjectType declaration as queries and mutations will be generated by scripts.

All the object declared here is an object that will have its own table on the database, hence
you also need to create Sequelize Models for the objects on [model.ts](../src/models/model.ts")

**Example**

For example, we will create two objects: Book and Author. 

First, write this inside your schemaModel.ts

```ts
const Schema = `
    scalar Timestamp
    type Book{
        id: ID
        createdAt: Timestamp
        updatedAt: Timestamp
        title: String!
        authorId: ID
        author: Author
    }

    type Author{
        id: ID
        createdAt: Timestamp
        updatedAt: Timestamp
        firstname: String!
        lastname: String
        books: [Book]
    }
`
export default {
    Schema
}
```

and on your model.ts
```ts
class Book extends Model{
    /**
     * relation defines which Model this Model related to.
     * It is used to get the corresponding value to that model
     */
    relation:ModelHandler = {
        "author": Author,
    }
}

Book.init({
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4(),
        allowNull: false,
        primaryKey: true,
        unique: true
    },
    createdAt: {
        type: DataTypes.TIME,
        allowNull: false,
        defaultValue: DataTypes.NOW()
    },
    updatedAt: {
        type: DataTypes.TIME,
        allowNull: false,
        defaultValue: DataTypes.NOW()
    },
    title: {
        type: DataTypes.STRING,
        allowNull: false
    },
    author:{
        /**
         * For nested GraphQL Object, you need to create a getter and set the field into virtual type since we don't actually create that column on the database.
         * 
         * This getter will search an actor where its id is the same as this model's authorId 
         */
        type: DataTypes.VIRTUAL,
        get(){
            return this.relation['author'].findOne({
                where:{
                    id: this.getDataValue('authorId')
                }
            })    
        }
    },
},{
    sequelize,
    freezeTableName: true,
    modelName: "Book"
})

class Author extends Model{
    relation:ModelHandler = {
        "book": Book,
    }
}

Author.init({
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4(),
        allowNull: false,
        primaryKey: true,
        unique: true
    },
    createdAt: {
        type: DataTypes.TIME,
        allowNull: false,
        defaultValue: DataTypes.NOW()
    },
    updatedAt: {
        type: DataTypes.TIME,
        allowNull: false,
        defaultValue: DataTypes.NOW()
    },
    firstname: {
        type: DataTypes.STRING,
        allowNull: false
    },
    lastname: {
        type: DataTypes.STRING,
        allowNull: false
    },
    age: {
        type: DataType.INT,
        allowNull: true
    }
    books:{
        type: DataTypes.VIRTUAL,
        get(){
            return this.relation['book'].findAll({
                where:{
                    authorId: this.getDataValue('id')
                }
            })    
        }
    },
},{
    sequelize,
    freezeTableName: true,
    modelName: "Book"
})
```

This will generate the following Operations on the schema.
```raw
Input:
    BookSearchInput
    BookInput
    AuthorSearchInput
    AuthorInput
Enum:
    BookSortField
    AuthorSortField
Query:
    getBook(id:ID):Book
    getBookFilteredList(
        search:BookSearchInput,
        searchAny:BookSearchInput,
        limit:Int,
        offset:Int,
        sortField:BookSortField,
        sortDirection:SortDirection
    ):[Book]
    getAuthor(id:ID):Author
    getAuthorFilteredList(
        search:AuthorSearchInput,
        searchAny:AuthorSearchInput,
        limit:Int,
        offset:Int,
        sortField:AuthorSortField,
        sortDirection:SortDirection
    ):[Author]
Mutation:
    insertBook(input:BookInput)
    insertMultipleBook(input:[BookInput])
    editBook(input:BookInput)
    editMultipleBook(input:[BookInput])
    deleteBook(id:ID)
    deleteMultipleBook(id:[ID])
    insertAuthor(input:AuthorInput)
    insertMultipleAuthor(input:[AuthorInput])
    editAuthor(input:AuthorInput)
    editMultipleAuthor(input:[AuthorInput])
    deleteAuthor(id:ID)
    deleteMultipleAuthor(id:[ID])
```

##### Operation explained

## Queries
A generated models will have 2 basic queries(currently). Namely: 
- get<ModelName>
- get<ModelName>FilteredList

From the above example we get

#### getAuthor
This query is used to get a single data by its id.

Required input: 
- id: ID

Query:
```graphql
query getAuthor($id:ID){
    getAuthor(id:$id){
        id
    }
}
```
Variables
```json
{
    "id": "YOUR ID"
}
```



#### getAuthorFilteredList
This query is used to get a list of filtered data of an object. This one is a bit tricky but very useful for querying. For it can use 6 input variables to limit, offset, sort and filter datas. If no input is used, it will function the same as getAuthorList (provided the variables is an empty dictionary `{  }`. otherwise it will thrown an error)

Possible input: 
- limit: Int
- offset: Int
- sortField: AuthorSortField (Requires sortDirection)
- sortDirection: SortDirection
- search: AuthorSearchInput
- searchAny: AuthorSearchInput

Where <ModelName>SearchInput is the fields of a model. So if the Model Author have a field of name, age, job. AuthorSearchInput will have the same fields, albeit a little more complex (eg. You cannot input {"age": 19} as an input). This complexity provide a more versatile way to search an entry, because it provide a way to use various operator(equal, greater,greater than, less, like) on its queries.

A search parameter required two fields which is:
- operator: (How you want to compare the data against the input value)
- value: (input value)

where the possible value of operator is:
- lt : less than
- lte : less than equals
- eq  : equals
- gte : greater than equals
- gt : greater than
- like : like (for string: case insensitive)
- not : not
- isEmpty
- notEmpty

Example
```json
{
    "firstname": [{"operator": "eq", "value": "Terry"}],
    "lastname": [{"operator": "like", "value": "Pratc%"}]
}
```

***search and searchAny***
search and searchAny is one of the most useful things in query. Any fields used in search will be used **exclusively** while searchAny will search the fields inclusively. In short, **search is and**, and **searchAny is or**.

For example, we will search a user with the following requirements.
- Age below 20 excluding 20 or above 50 including 50
- Job must be a doctor
- Sort Descending by Age

Then the query would be

Query:
```graphql
query getAuthorFilteredList($search:AuthorSearchInput,$searchAny:AuthorSearchInput,$sortField:AuthorSortField){
    getAuthor(search:$search, searchAny:$searchAny, sortField: $sortField, sortDirection: DESC){
        id
        firstname
        lastname
        age
        books{
            title
        }
    }
}
```
Variables
```json
{
    "searchAny":{
        "age":[
        {"operator": "lt", "value": 20},
        {"operator":  "gte", "value": 50}
        ]
    },
    "search":{
        "firstname":[{"operator": "like", "value": "Thomas"}]
    },
    "sortField": "age"
}
```

#### insertAuthor
This is the mutation if you want to create a new entry on your database.
```graphql
mutation insertAuthor($input:AuthorInput){
    insertAuthor(input:$input){
        firstname
        lastname
        age
    }
}
```

```json
{
    "input":{
        "firstname": "Herman",
        "lastname": "Melville",
        "age": 80
    }
}
```

#### insertMultipleAuthor

This is the mutation if you want to create multiple new entry on your database.
```graphql
mutation insertMultipleAuthor($input:[AuthorInput]){
    insertMultipleAuthor(input:$input){
        firstname
        lastname
        age
    }
}
```

```json
{
    "input":[
        { "firstname": "Herman", "lastname": "Melville", "age": 80 },
        { "firstname": "Hunter", "lastname": "Thompson", "age": 68}    
    ]
}
```

#### editAuthor and editMultipleAuthor
Editing data is similar to insert data, except you have to include the row id.
```graphql
mutation editMultipleAuthor($input:[AuthorInput]){
    editMultipleAuthor(input:$input){
        firstname
        lastname
        age
    }
}
```

```json
{
    "input":[
        { "id": "someUUID", "age": 81 },
        { "id": "someUUID", "firstname": "Hunter S", "lastname": "Thompson", "age": 68}    
    ]
}
```